import q from "node:path";
import { ESLintUtils as ge, ASTUtils as J } from "@typescript-eslint/utils";
import { minimatch as U } from "minimatch";
import ye from "natural-compare-lite";
import { AST_NODE_TYPES as fe } from "@typescript-eslint/types";
import { builtinModules as me } from "node:module";
let A = ge.RuleCreator(
  (e) => `https://eslint-plugin-perfectionist.azat.io/rules/${e}`
), E = (e, i) => {
  for (let a = 0, l = e.length; a < l; a++) {
    let s = e[a];
    if (i.group === s || Array.isArray(s) && typeof i.group == "string" && s.includes(i.group))
      return a;
  }
  return e.length;
}, I = (e) => {
  let [i, a] = e;
  return a - i;
}, O = (e) => e > 0;
var u = /* @__PURE__ */ ((e) => (e.alphabetical = "alphabetical", e["line-length"] = "line-length", e.natural = "natural", e))(u || {}), m = /* @__PURE__ */ ((e) => (e.desc = "desc", e.asc = "asc", e))(m || {}), T = /* @__PURE__ */ ((e) => (e["values-first"] = "values-first", e["types-first"] = "types-first", e.mixed = "mixed", e))(T || {}), G = /* @__PURE__ */ ((e) => (e["optional-first"] = "optional-first", e["required-first"] = "required-first", e.ignore = "ignore", e))(G || {});
let R = (e) => {
  let i, a = (s) => {
    !i && e.flat().includes(s) && (i = s);
  };
  return {
    getGroup: () => i ?? "unknown",
    setCustomGroups: (s, r) => {
      if (s)
        for (let [n, p] of Object.entries(s))
          Array.isArray(p) && p.some(
            (t) => U(r, t, {
              nocomment: !0
            })
          ) && a(n), typeof p == "string" && U(r, p, {
            nocomment: !0
          }) && a(n);
    },
    defineGroup: a
  };
}, w = (e, i, a) => {
  var n, p;
  if ((n = i.dependencies) != null && n.includes(e.name))
    return -1;
  if ((p = e.dependencies) != null && p.includes(i.name))
    return 1;
  let l = a.order === "asc" ? 1 : -1, s, r = (t) => a["ignore-case"] ? t.toLowerCase() : t;
  return a.type === u.alphabetical ? s = (t, o) => r(t.name).localeCompare(r(o.name)) : a.type === u.natural ? s = (t, o) => ye(r(t.name), r(o.name)) : s = (t, o) => {
    let f = t.size, c = o.size, d = a["max-line-length"];
    if (d) {
      let g = (y, b) => y > d && b.hasMultipleImportDeclarations;
      g(f, t) && (f = t.name.length + 10), g(c, o) && (c = o.name.length + 10);
    }
    return f - c;
  }, l * s(e, i);
}, v = (e, i) => [...e].sort((a, l) => w(a, l, i)), he = (e, i) => {
  let a = i.getTokenAfter(e, {
    filter: ({ value: l, type: s }) => !(s === "Punctuator" && [",", ";"].includes(l)),
    includeComments: !0
  });
  return ((a == null ? void 0 : a.type) === "Block" || (a == null ? void 0 : a.type) === "Line") && e.loc.end.line === a.loc.end.line ? a : null;
}, Y = (e, i) => Array.isArray(e) && e.some(
  (a) => U(i.trim(), a, {
    nocomment: !0
  })
) || typeof e == "string" && U(i.trim(), e, {
  nocomment: !0
}) || e === !0, K = (e, i) => {
  let [a, l] = i.getTokensBefore(e, {
    filter: ({ value: s, type: r }) => !(r === "Punctuator" && [",", ";"].includes(s)),
    includeComments: !0,
    count: 2
  });
  return ((l == null ? void 0 : l.type) === "Block" || (l == null ? void 0 : l.type) === "Line") && e.loc.start.line - l.loc.end.line <= 1 && (a == null ? void 0 : a.loc.end.line) !== l.loc.start.line ? l : null;
}, L = (e, i, a) => {
  var p;
  let l = e.range.at(0), s = e.range.at(1), r = i.text.slice(l, s);
  if (J.isParenthesized(e, i)) {
    let t = i.getTokenBefore(
      e,
      J.isOpeningParenToken
    ), o = i.getTokenAfter(
      e,
      J.isClosingParenToken
    );
    l = t.range.at(0), s = o.range.at(1);
  }
  let n = K(e, i);
  if (r.endsWith(";") || r.endsWith(",")) {
    let t = i.getTokensAfter(e, {
      includeComments: !0,
      count: 2
    });
    e.loc.start.line === ((p = t.at(1)) == null ? void 0 : p.loc.start.line) && (s -= 1);
  }
  return n && !Y(
    (a == null ? void 0 : a.partitionComment) ?? !1,
    n.value
  ) && (l = n.range.at(0)), [l, s];
}, M = (e, i, a, l, s) => {
  var p, t;
  let r = [], n = ((p = i.at(0)) == null ? void 0 : p.node.loc.start.line) === ((t = i.at(-1)) == null ? void 0 : t.node.loc.end.line);
  for (let o = 0, f = i.length; o < f; o++) {
    let { node: c } = i.at(o);
    r.push(
      e.replaceTextRange(
        L(c, l, s),
        l.text.slice(
          ...L(a.at(o).node, l, s)
        )
      )
    );
    let d = he(a.at(o).node, l);
    if (d && !n) {
      let y = [
        l.getTokenBefore(d).range.at(1),
        d.range.at(1)
      ];
      r.push(e.replaceTextRange(y, ""));
      let b = l.getTokenAfter(c);
      r.push(
        e.insertTextAfter(
          (b == null ? void 0 : b.loc.end.line) === c.loc.end.line ? b : c,
          l.text.slice(...y)
        )
      );
    }
  }
  return r;
}, j = (e = {}, i) => Object.assign(i, e), P = (e, i) => {
  if (e.length > 1)
    for (let a = 1; a < e.length; a++) {
      let l = e.at(a - 1), s = e.at(a);
      l && s && i(l, s, a - 1);
    }
};
const H = "sort-svelte-attributes", be = A({
  name: H,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Svelte attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedSvelteAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => q.extname(e.filename) !== ".svelte" ? {} : {
    SvelteStartTag: (i) => {
      if (i.attributes.length > 1) {
        let a = j(e.options.at(0), {
          type: u.alphabetical,
          order: m.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), l = i.attributes.reduce(
          (s, r) => {
            if (r.type === "SvelteSpreadAttribute")
              return s.push([]), s;
            let n, { getGroup: p, defineGroup: t, setCustomGroups: o } = R(
              a.groups
            );
            return r.key.type === "SvelteSpecialDirectiveKey" ? n = e.sourceCode.text.slice(...r.key.range) : typeof r.key.name == "string" ? { name: n } = r.key : n = e.sourceCode.text.slice(...r.key.range), o(a["custom-groups"], n), r.type === "SvelteShorthandAttribute" && (t("svelte-shorthand"), t("shorthand")), (!("value" in r) || Array.isArray(r.value) && !r.value.at(0)) && t("shorthand"), r.loc.start.line !== r.loc.end.line && t("multiline"), s.at(-1).push({
              size: I(r.range),
              node: r,
              group: p(),
              name: n
            }), s;
          },
          [[]]
        );
        for (let s of l)
          P(s, (r, n) => {
            let p = E(a.groups, r), t = E(a.groups, n);
            (p > t || p === t && O(w(r, n, a))) && e.report({
              messageId: "unexpectedSvelteAttributesOrder",
              data: {
                left: r.name,
                right: n.name
              },
              node: n.node,
              fix: (o) => {
                let f = {};
                for (let d of s) {
                  let g = E(a.groups, d);
                  g in f ? f[g] = v(
                    [...f[g], d],
                    a
                  ) : f[g] = [d];
                }
                let c = [];
                for (let d of Object.keys(f).sort(
                  (g, y) => Number(g) - Number(y)
                ))
                  c.push(...v(f[d], a));
                return M(
                  o,
                  s,
                  c,
                  e.sourceCode
                );
              }
            });
          });
      }
    }
  }
}), Q = "sort-astro-attributes", xe = A({
  name: Q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Astro attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedAstroAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  // @ts-ignore
  create: (e) => q.extname(e.filename) !== ".astro" ? {} : {
    JSXElement: (i) => {
      let { attributes: a } = i.openingElement;
      if (a.length > 1) {
        let l = j(e.options.at(0), {
          type: u.alphabetical,
          order: m.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), s = a.reduce(
          (r, n) => {
            if (n.type === "JSXSpreadAttribute")
              return r.push([]), r;
            let p = typeof n.name.name == "string" ? n.name.name : e.sourceCode.text.slice(...n.name.range), { getGroup: t, defineGroup: o, setCustomGroups: f } = R(
              l.groups
            );
            return f(l["custom-groups"], p), n.type === "AstroShorthandAttribute" && (o("astro-shorthand"), o("shorthand")), n.value === null && o("shorthand"), n.loc.start.line !== n.loc.end.line && o("multiline"), r.at(-1).push({
              size: I(n.range),
              node: n,
              group: t(),
              name: p
            }), r;
          },
          [[]]
        );
        for (let r of s)
          P(r, (n, p) => {
            let t = E(l.groups, n), o = E(l.groups, p);
            (t > o || t === o && O(w(n, p, l))) && e.report({
              messageId: "unexpectedAstroAttributesOrder",
              data: {
                left: n.name,
                right: p.name
              },
              node: p.node,
              fix: (f) => {
                let c = {};
                for (let g of r) {
                  let y = E(l.groups, g);
                  y in c ? c[y] = v(
                    [...c[y], g],
                    l
                  ) : c[y] = [g];
                }
                let d = [];
                for (let g of Object.keys(c).sort(
                  (y, b) => Number(y) - Number(b)
                ))
                  d.push(...v(c[g], l));
                return M(
                  f,
                  r,
                  d,
                  e.sourceCode
                );
              }
            });
          });
      }
    }
  }
});
let k = (e) => e.replaceAll(/\s\s+/g, " ").trim();
const Z = "sort-array-includes", Ee = A({
  name: Z,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted arrays before include method"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "spread-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedArrayIncludesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    MemberExpression: (i) => {
      if ((i.object.type === "ArrayExpression" || i.object.type === "NewExpression") && i.property.type === "Identifier" && i.property.name === "includes") {
        let a = i.object.type === "ArrayExpression" ? i.object.elements : i.object.arguments;
        if (a.length > 1) {
          let l = j(e.options.at(0), {
            type: u.alphabetical,
            order: m.asc,
            "ignore-case": !1,
            "spread-last": !1
          }), s = a.reduce(
            (r, n) => (n !== null && r.at(0).push({
              name: n.type === "Literal" ? `${n.value}` : e.sourceCode.text.slice(...n.range),
              size: I(n.range),
              type: n.type,
              node: n
            }), r),
            [[], []]
          ).flat();
          P(s, (r, n) => {
            let p;
            l["spread-last"] && r.node.type === "Literal" && n.node.type === "SpreadElement" ? p = !1 : l["spread-last"] && r.node.type === "SpreadElement" && n.node.type === "Literal" ? p = !0 : p = O(w(r, n, l)), p && e.report({
              messageId: "unexpectedArrayIncludesOrder",
              data: {
                left: k(r.name),
                right: k(n.name)
              },
              node: n.node,
              fix: (t) => {
                let o = v(s, l);
                if (l["spread-last"])
                  for (let f = 0, c = o.length; f < c; f++)
                    o.at(f).node.type === "SpreadElement" && o.push(o.splice(f, 1).at(0));
                return M(
                  t,
                  s,
                  o,
                  e.sourceCode
                );
              }
            });
          });
        }
      }
    }
  })
}), F = "sort-vue-attributes", Ne = A({
  name: F,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Vue attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedVueAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => {
    if (q.extname(e.filename) !== ".vue")
      return {};
    if (!("defineTemplateBodyVisitor" in e.sourceCode.parserServices))
      return {};
    let { defineTemplateBodyVisitor: i } = e.sourceCode.parserServices;
    return i({
      VStartTag: (a) => {
        if (a.attributes.length > 1) {
          let l = j(e.options.at(0), {
            type: u.alphabetical,
            order: m.asc,
            "ignore-case": !1,
            "custom-groups": {},
            groups: []
          }), s = a.attributes.reduce(
            (r, n) => {
              if (n.key.type === "VDirectiveKey" && n.key.name.rawName === "bind")
                return r.push([]), r;
              let p, { getGroup: t, defineGroup: o, setCustomGroups: f } = R(
                l.groups
              );
              return typeof n.key.name == "string" && n.key.type !== "VDirectiveKey" ? p = n.key.rawName : p = e.sourceCode.text.slice(...n.key.range), f(l["custom-groups"], p), n.value === null && o("shorthand"), n.loc.start.line !== n.loc.end.line && o("multiline"), r.at(-1).push({
                size: I(n.range),
                node: n,
                group: t(),
                name: p
              }), r;
            },
            [[]]
          );
          for (let r of s)
            P(r, (n, p) => {
              let t = E(l.groups, n), o = E(l.groups, p);
              (t > o || t === o && O(w(n, p, l))) && e.report({
                messageId: "unexpectedVueAttributesOrder",
                data: {
                  left: n.name,
                  right: p.name
                },
                node: p.node,
                fix: (f) => {
                  let c = {};
                  for (let g of r) {
                    let y = E(l.groups, g);
                    y in c ? c[y] = v(
                      [...c[y], g],
                      l
                    ) : c[y] = [g];
                  }
                  let d = [];
                  for (let g of Object.keys(c).sort(
                    (y, b) => Number(y) - Number(b)
                  ))
                    d.push(...v(c[g], l));
                  return M(
                    f,
                    r,
                    d,
                    e.sourceCode
                  );
                }
              });
            });
        }
      }
    });
  }
}), ee = "sort-named-exports", Ce = A({
  name: ee,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "group-kind": {
            enum: [
              T.mixed,
              T["values-first"],
              T["types-first"]
            ],
            default: T.mixed,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    ExportNamedDeclaration: (i) => {
      if (i.specifiers.length > 1) {
        let a = j(e.options.at(0), {
          type: u.alphabetical,
          "ignore-case": !1,
          order: m.asc,
          "group-kind": T.mixed
        }), l = i.specifiers.map((n) => ({
          size: I(n.range),
          name: n.local.name,
          node: n,
          group: n.exportKind
        })), s = a["group-kind"] !== T.mixed, r = a["group-kind"] === T["values-first"] ? ["value", "type"] : ["type", "value"];
        P(l, (n, p) => {
          let t = E(r, n), o = E(r, p);
          if (s && t > o || (!s || t === o) && O(w(n, p, a))) {
            let f = s ? r.map((c) => l.filter((d) => d.group === c)).map((c) => v(c, a)).flat() : v(l, a);
            e.report({
              messageId: "unexpectedNamedExportsOrder",
              data: {
                left: n.name,
                right: p.name
              },
              node: p.node,
              fix: (c) => M(c, l, f, e.sourceCode)
            });
          }
        });
      }
    }
  })
}), te = "sort-named-imports", ve = A({
  name: te,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-alias": {
            type: "boolean",
            default: !1
          },
          "group-kind": {
            enum: [
              T.mixed,
              T["values-first"],
              T["types-first"]
            ],
            default: T.mixed,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    ImportDeclaration: (i) => {
      let a = i.specifiers.filter(
        ({ type: l }) => l === "ImportSpecifier"
      );
      if (a.length > 1) {
        let l = j(e.options.at(0), {
          type: u.alphabetical,
          "ignore-alias": !0,
          "ignore-case": !1,
          order: m.asc,
          "group-kind": T.mixed
        }), s = a.map((p) => {
          let t, { name: o } = p.local;
          return p.type === "ImportSpecifier" && (l["ignore-alias"] && ({ name: o } = p.imported), t = p.importKind), {
            size: I(p.range),
            node: p,
            name: o,
            group: t
          };
        }), r = l["group-kind"] !== T.mixed, n = l["group-kind"] === T["values-first"] ? ["value", "type"] : ["type", "value"];
        P(s, (p, t) => {
          let o = E(n, p), f = E(n, t);
          if (r && o > f || (!r || o === f) && O(w(p, t, l))) {
            let c = r ? n.map((d) => s.filter((g) => g.group === d)).map((d) => v(d, l)).flat() : v(s, l);
            e.report({
              messageId: "unexpectedNamedImportsOrder",
              data: {
                left: p.name,
                right: t.name
              },
              node: t.node,
              fix: (d) => M(d, s, c, e.sourceCode)
            });
          }
        });
      }
    }
  })
});
let W = (e, i, a) => e.lines.slice(
  i.node.loc.end.line,
  a.node.loc.start.line - 1
).filter((s) => !s.trim().length).length;
const re = "sort-object-types", Se = A({
  name: re,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted object types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    TSTypeLiteral: (i) => {
      if (i.members.length > 1) {
        let a = j(e.options.at(0), {
          "partition-by-new-line": !1,
          type: u.alphabetical,
          "ignore-case": !1,
          order: m.asc,
          "custom-groups": {},
          groups: []
        }), l = i.members.reduce(
          (s, r) => {
            var C, h, N, x;
            let n, p = e.sourceCode.text.slice(
              r.range.at(0),
              r.range.at(1)
            ), t = (C = s.at(-1)) == null ? void 0 : C.at(-1), { getGroup: o, defineGroup: f, setCustomGroups: c } = R(
              a.groups
            ), d = (S) => S.replace(/(,|;)$/, "");
            if (r.type === "TSPropertySignature")
              r.key.type === "Identifier" ? { name: n } = r.key : r.key.type === "Literal" ? n = `${r.key.value}` : n = e.sourceCode.text.slice(
                r.range.at(0),
                (h = r.typeAnnotation) == null ? void 0 : h.range.at(0)
              );
            else if (r.type === "TSIndexSignature") {
              let S = ((N = r.typeAnnotation) == null ? void 0 : N.range.at(0)) ?? r.range.at(1);
              n = d(
                e.sourceCode.text.slice(r.range.at(0), S)
              );
            } else
              n = d(
                e.sourceCode.text.slice(
                  r.range.at(0),
                  r.range.at(1)
                )
              );
            c(a["custom-groups"], n), r.loc.start.line !== r.loc.end.line && f("multiline");
            let y = p.endsWith(";") || p.endsWith(",") ? 1 : 0, b = {
              size: I(r.range) - y,
              node: r,
              name: n
            };
            return a["partition-by-new-line"] && t && W(e.sourceCode, t, b) && s.push([]), (x = s.at(-1)) == null || x.push({
              ...b,
              group: o()
            }), s;
          },
          [[]]
        );
        for (let s of l)
          P(s, (r, n) => {
            let p = E(a.groups, r), t = E(a.groups, n);
            (p > t || p === t && O(w(r, n, a))) && e.report({
              messageId: "unexpectedObjectTypesOrder",
              data: {
                left: k(r.name),
                right: k(n.name)
              },
              node: n.node,
              fix: (o) => {
                let f = {};
                for (let d of s) {
                  let g = E(a.groups, d);
                  g in f ? f[g] = v(
                    [...f[g], d],
                    a
                  ) : f[g] = [d];
                }
                let c = [];
                for (let d of Object.keys(f).sort(
                  (g, y) => Number(g) - Number(y)
                ))
                  c.push(...v(f[d], a));
                return M(
                  o,
                  s,
                  c,
                  e.sourceCode
                );
              }
            });
          });
      }
    }
  })
}), se = "sort-union-types", we = A({
  name: se,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted union types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "nullable-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedUnionTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    TSUnionType: (i) => {
      let a = j(e.options.at(0), {
        type: u.alphabetical,
        "nullable-last": !1,
        "ignore-case": !1,
        order: m.asc
      }), l = i.types.map((s) => ({
        group: s.type === "TSNullKeyword" || s.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
        name: e.sourceCode.text.slice(...s.range),
        size: I(s.range),
        node: s
      }));
      P(l, (s, r) => {
        let n = O(w(s, r, a));
        a["nullable-last"] && (s.group === "nullable" && r.group === "unknown" ? n = !0 : s.group === "unknown" && r.group === "nullable" && (n = !1)), n && e.report({
          messageId: "unexpectedUnionTypesOrder",
          data: {
            left: k(s.name),
            right: k(r.name)
          },
          node: r.node,
          fix: (p) => {
            let t = [];
            if (a["nullable-last"]) {
              let o = [], f = l.filter((c) => c.group === "nullable" ? (o.push(c), !1) : !0);
              t = [
                ...v(f, a),
                ...v(o, a)
              ];
            } else
              t = v(l, a);
            return M(p, l, t, e.sourceCode);
          }
        });
      });
    }
  })
});
let B = (e) => {
  switch (e.type) {
    case fe.TSMethodSignature:
    case fe.TSPropertySignature:
      return e.optional;
  }
  return !1;
};
const ae = "sort-interfaces", ke = A({
  name: ae,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted interface properties"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          "optionality-order": {
            enum: [
              G.ignore,
              G["optional-first"],
              G["required-first"]
            ],
            default: G.ignore,
            type: "string"
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array",
            default: []
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedInterfacePropertiesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    TSInterfaceDeclaration: (i) => {
      if (i.body.body.length > 1) {
        let a = j(e.options.at(0), {
          "optionality-order": G.ignore,
          "partition-by-new-line": !1,
          type: u.alphabetical,
          "ignore-case": !1,
          order: m.asc,
          "ignore-pattern": [],
          "custom-groups": {},
          groups: []
        });
        if (!a["ignore-pattern"].some(
          (l) => U(i.id.name, l, {
            nocomment: !0
          })
        )) {
          let l = i.body.body.reduce(
            (t, o) => {
              var C, h, N, x;
              if (o.type === "TSCallSignatureDeclaration")
                return t.push([]), t;
              let f = (C = t.at(-1)) == null ? void 0 : C.at(-1), c, { getGroup: d, defineGroup: g, setCustomGroups: y } = R(
                a.groups
              );
              if (o.type === "TSPropertySignature")
                if (o.key.type === "Identifier")
                  ({ name: c } = o.key);
                else if (o.key.type === "Literal")
                  c = `${o.key.value}`;
                else {
                  let S = ((h = o.typeAnnotation) == null ? void 0 : h.range.at(0)) ?? o.range.at(1) - (o.optional ? 1 : 0);
                  c = e.sourceCode.text.slice(o.range.at(0), S);
                }
              else if (o.type === "TSIndexSignature") {
                let S = ((N = o.typeAnnotation) == null ? void 0 : N.range.at(0)) ?? o.range.at(1);
                c = e.sourceCode.text.slice(
                  o.range.at(0),
                  S
                );
              } else {
                let S = ((x = o.returnType) == null ? void 0 : x.range.at(0)) ?? o.range.at(1);
                c = e.sourceCode.text.slice(
                  o.range.at(0),
                  S
                );
              }
              let b = {
                size: I(o.range),
                node: o,
                name: c
              };
              return a["partition-by-new-line"] && f && W(
                e.sourceCode,
                f,
                b
              ) && t.push([]), y(a["custom-groups"], c), o.loc.start.line !== o.loc.end.line && g("multiline"), t.at(-1).push({
                ...b,
                group: d()
              }), t;
            },
            [[]]
          ), s = (t) => {
            let o = {};
            for (let c of t) {
              let d = E(a.groups, c);
              d in o ? o[d] = v(
                [...o[d], c],
                a
              ) : o[d] = [c];
            }
            let f = [];
            for (let c of Object.keys(o).sort(
              (d, g) => Number(d) - Number(g)
            ))
              f.push(...v(o[c], a));
            return f;
          }, r = (t, o) => {
            let f = E(a.groups, t), c = E(a.groups, o);
            return f > c || f === c && O(w(t, o, a));
          }, n = a["optionality-order"], p = (t, o, f, c) => {
            if (n === G.ignore)
              return r(o, f);
            let d = t.findIndex(
              (g, y) => y && B(t[y - 1].node) !== B(t[y].node)
            );
            return c < d && c + 1 !== d ? r(o, f) : B(o.node) !== B(f.node) ? B(o.node) !== (n === G["optional-first"]) : r(o, f);
          };
          for (let t of l)
            P(t, (o, f, c) => {
              p(t, o, f, c) && e.report({
                messageId: "unexpectedInterfacePropertiesOrder",
                data: {
                  left: k(o.name),
                  right: k(f.name)
                },
                node: f.node,
                fix: (d) => {
                  let g;
                  if (n !== G.ignore) {
                    let y = t.filter(
                      (C) => B(C.node)
                    ), b = t.filter(
                      (C) => !B(C.node)
                    );
                    g = n === G["optional-first"] ? [
                      ...s(y),
                      ...s(b)
                    ] : [
                      ...s(b),
                      ...s(y)
                    ];
                  } else
                    g = s(t);
                  return M(
                    d,
                    t,
                    g,
                    e.sourceCode
                  );
                }
              });
            });
        }
      }
    }
  })
}), oe = "sort-jsx-props", Ae = A({
  name: oe,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted JSX props"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          groups: {
            type: "array"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedJSXPropsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => [".svelte", ".astro", ".vue"].includes(q.extname(e.filename)) ? {} : {
    JSXElement: (i) => {
      if (i.openingElement.attributes.length > 1) {
        let a = j(e.options.at(0), {
          type: u.alphabetical,
          "ignore-case": !1,
          order: m.asc,
          "custom-groups": {},
          groups: []
        }), l = i.openingElement.attributes.reduce(
          (s, r) => {
            if (r.type === "JSXSpreadAttribute")
              return s.push([]), s;
            let n = r.name.type === "JSXNamespacedName" ? `${r.name.namespace.name}:${r.name.name.name}` : r.name.name, { getGroup: p, defineGroup: t, setCustomGroups: o } = R(
              a.groups
            );
            o(a["custom-groups"], n), r.value === null && t("shorthand"), r.loc.start.line !== r.loc.end.line && t("multiline");
            let f = {
              size: I(r.range),
              group: p(),
              node: r,
              name: n
            };
            return s.at(-1).push(f), s;
          },
          [[]]
        );
        for (let s of l)
          P(s, (r, n) => {
            let p = E(a.groups, r), t = E(a.groups, n);
            (p > t || p === t && O(w(r, n, a))) && e.report({
              messageId: "unexpectedJSXPropsOrder",
              data: {
                left: r.name,
                right: n.name
              },
              node: n.node,
              fix: (o) => {
                let f = {};
                for (let d of s) {
                  let g = E(a.groups, d);
                  g in f ? f[g] = v(
                    [...f[g], d],
                    a
                  ) : f[g] = [d];
                }
                let c = [];
                for (let d of Object.keys(f).sort(
                  (g, y) => Number(g) - Number(y)
                ))
                  c.push(...v(f[d], a));
                return M(
                  o,
                  s,
                  c,
                  e.sourceCode
                );
              }
            });
          });
      }
    }
  }
}), ne = "sort-exports", Ie = A({
  name: ne,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => {
    let i = j(e.options.at(0), {
      type: u.alphabetical,
      order: m.asc,
      "ignore-case": !1
    }), a = [[]], l = (s) => {
      s.type === "ExportAllDeclaration" && s.exported === null ? a.push([]) : a.at(-1).push({
        size: I(s.range),
        name: s.source.value,
        node: s
      });
    };
    return {
      ExportAllDeclaration: l,
      ExportNamedDeclaration: (s) => {
        s.source !== null && l(s);
      },
      "Program:exit": () => {
        for (let s of a)
          P(s, (r, n) => {
            O(w(r, n, i)) && e.report({
              messageId: "unexpectedExportsOrder",
              data: {
                left: r.name,
                right: n.name
              },
              node: n.node,
              fix: (p) => M(
                p,
                s,
                v(s, i),
                e.sourceCode
              )
            });
          });
      }
    };
  }
}), le = "sort-imports", Oe = A({
  name: le,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted imports"
    },
    fixable: "code",
    schema: [
      {
        id: "sort-imports",
        type: "object",
        properties: {
          "custom-groups": {
            type: "object",
            properties: {
              type: {
                type: "object"
              },
              value: {
                type: "object"
              }
            },
            additionalProperties: !1
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "internal-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          "newlines-between": {
            enum: [
              "ignore",
              "always",
              "never"
              /* never */
            ],
            default: "always",
            type: "string"
          },
          "max-line-length": {
            type: "integer",
            minimum: 0,
            exclusiveMinimum: !0
          }
        },
        allOf: [
          { $ref: "#/definitions/max-line-length-requires-line-length-type" }
        ],
        additionalProperties: !1,
        dependencies: {
          "max-line-length": ["type"]
        },
        definitions: {
          "is-line-length": {
            properties: {
              type: { enum: [u["line-length"]], type: "string" }
            },
            required: ["type"],
            type: "object"
          },
          "max-line-length-requires-line-length-type": {
            anyOf: [
              {
                not: { required: ["max-line-length"], type: "object" },
                type: "object"
              },
              { $ref: "#/definitions/is-line-length" }
            ]
          }
        }
      }
    ],
    messages: {
      unexpectedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"',
      missedSpacingBetweenImports: 'Missed spacing between "{{left}}" and "{{right}}" imports',
      extraSpacingBetweenImports: 'Extra spacing between "{{left}}" and "{{right}}" imports'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => {
    let i = j(e.options.at(0), {
      "newlines-between": "always",
      "custom-groups": { type: {}, value: {} },
      "internal-pattern": ["~/**"],
      type: u.alphabetical,
      order: m.asc,
      "ignore-case": !1,
      groups: []
    }), a = !1;
    for (let t of i.groups)
      if (Array.isArray(t))
        for (let o of t)
          o === "unknown" && (a = !0);
      else
        t === "unknown" && (a = !0);
    a || (i.groups = [...i.groups, "unknown"]);
    let l = [], s = (t) => t.type === "ImportDeclaration" && t.specifiers.length === 0, r = (t) => {
      let o = (x) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
        (S) => x.endsWith(S)
      ), f = (x) => [
        "./index.d.js",
        "./index.d.ts",
        "./index.js",
        "./index.ts",
        "./index",
        "./",
        "."
      ].includes(x), c = (x) => x.indexOf("..") === 0, d = (x) => x.indexOf("./") === 0, { getGroup: g, defineGroup: y, setCustomGroups: b } = R(i.groups), C = (x) => i["internal-pattern"].length && i["internal-pattern"].some(
        (S) => U(x.source.value, S, {
          nocomment: !0
        })
      ), h = (x) => {
        let S = [
          "bun",
          "bun:ffi",
          "bun:jsc",
          "bun:sqlite",
          "bun:test",
          "bun:wrap",
          "detect-libc",
          "undici",
          "ws"
        ];
        return me.includes(
          x.startsWith("node:") ? x.split("node:")[1] : x
        ) || S.includes(x);
      }, N = (x) => !(x.startsWith(".") || x.startsWith("/"));
      return t.importKind === "type" && (t.type === "ImportDeclaration" && (b(i["custom-groups"].type, t.source.value), f(t.source.value) && y("index-type"), d(t.source.value) && y("sibling-type"), c(t.source.value) && y("parent-type"), C(t) && y("internal-type"), h(t.source.value) && y("builtin-type"), N(t.source.value) && y("external-type")), y("type")), t.type === "ImportDeclaration" && (b(i["custom-groups"].value, t.source.value), s(t) && o(t.source.value) && y("side-effect-style"), s(t) && y("side-effect"), o(t.source.value) && y("style"), f(t.source.value) && y("index"), d(t.source.value) && y("sibling"), c(t.source.value) && y("parent"), C(t) && y("internal"), h(t.source.value) && y("builtin"), N(t.source.value) && y("external")), g();
    }, n = (t) => t.specifiers.length > 1, p = (t) => {
      let o;
      t.type === "ImportDeclaration" ? o = t.source.value : t.moduleReference.type === "TSExternalModuleReference" && t.moduleReference.expression.type === "Literal" ? o = `${t.moduleReference.expression.value}` : o = e.sourceCode.text.slice(...t.moduleReference.range), l.push({
        size: I(t.range),
        group: r(t),
        name: o,
        node: t,
        ...i.type === u["line-length"] && i["max-line-length"] && {
          hasMultipleImportDeclarations: n(
            t
          )
        }
      });
    };
    return {
      TSImportEqualsDeclaration: p,
      ImportDeclaration: p,
      "Program:exit": () => {
        var c;
        let t = (d, g) => !!e.sourceCode.getTokensBetween(
          d.node,
          K(g.node, e.sourceCode) || g.node,
          {
            includeComments: !0
          }
        ).length, o = (d, g) => {
          let y = [], b = {};
          for (let h of g) {
            let N = E(i.groups, h);
            N in b ? b[N] = v(
              [...b[N], h],
              i
            ) : b[N] = [h];
          }
          let C = Object.keys(b).sort((h, N) => Number(h) - Number(N)).reduce(
            (h, N) => [
              ...h,
              ...b[N]
            ],
            []
          );
          for (let h = 0, N = C.length; h < N; h++) {
            let x = C.at(h);
            if (y.push(
              d.replaceTextRange(
                L(g.at(h).node, e.sourceCode),
                e.sourceCode.text.slice(
                  ...L(x.node, e.sourceCode)
                )
              )
            ), i["newlines-between"] !== "ignore") {
              let S = C.at(h + 1);
              if (S) {
                let $ = W(
                  e.sourceCode,
                  g.at(h),
                  g.at(h + 1)
                );
                (i["newlines-between"] === "always" && E(i.groups, x) === E(i.groups, S) && $ !== 0 || i["newlines-between"] === "never" && $ > 0) && y.push(
                  d.removeRange([
                    L(
                      g.at(h).node,
                      e.sourceCode
                    ).at(1),
                    L(
                      g.at(h + 1).node,
                      e.sourceCode
                    ).at(0) - 1
                  ])
                ), i["newlines-between"] === "always" && E(i.groups, x) !== E(i.groups, S) && $ > 1 && y.push(
                  d.replaceTextRange(
                    [
                      L(
                        g.at(h).node,
                        e.sourceCode
                      ).at(1),
                      L(
                        g.at(h + 1).node,
                        e.sourceCode
                      ).at(0) - 1
                    ],
                    `
`
                  )
                ), i["newlines-between"] === "always" && E(i.groups, x) !== E(i.groups, S) && $ === 0 && y.push(
                  d.insertTextAfterRange(
                    L(g.at(h).node, e.sourceCode),
                    `
`
                  )
                );
              }
            }
          }
          return y;
        }, f = [[]];
        for (let d of l) {
          let g = (c = f.at(-1)) == null ? void 0 : c.at(-1);
          g && t(g, d) ? f.push([d]) : f.at(-1).push(d);
        }
        for (let d of f)
          P(d, (g, y) => {
            let b = E(i.groups, g), C = E(i.groups, y), h = W(
              e.sourceCode,
              g,
              y
            );
            !(s(g.node) && s(y.node)) && !t(g, y) && (b > C || b === C && O(w(g, y, i))) && e.report({
              messageId: "unexpectedImportsOrder",
              data: {
                left: g.name,
                right: y.name
              },
              node: y.node,
              fix: (N) => o(N, d)
            }), i["newlines-between"] === "never" && h > 0 && e.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: g.name,
                right: y.name
              },
              node: y.node,
              fix: (N) => o(N, d)
            }), i["newlines-between"] === "always" && (b < C && h === 0 ? e.report({
              messageId: "missedSpacingBetweenImports",
              data: {
                left: g.name,
                right: y.name
              },
              node: y.node,
              fix: (N) => o(N, d)
            }) : (h > 1 || b === C && h > 0) && e.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: g.name,
                right: y.name
              },
              node: y.node,
              fix: (N) => o(N, d)
            }));
          });
      }
    };
  }
}), ie = "sort-objects", je = A({
  name: ie,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted objects"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          "partition-by-comment": {
            type: ["boolean", "string", "array"],
            default: !1
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          },
          "styled-components": {
            type: "boolean",
            default: !0
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => {
    let i = (a) => {
      let l = j(e.options.at(0), {
        "partition-by-new-line": !1,
        "partition-by-comment": !1,
        type: u.alphabetical,
        "styled-components": !0,
        "ignore-case": !1,
        "ignore-pattern": [],
        order: m.asc,
        "custom-groups": {},
        groups: []
      }), s = a.parent.type === "VariableDeclarator" && a.parent.id.type === "Identifier" ? a.parent.id.name : null;
      if (!(l["ignore-pattern"].length && typeof s == "string" ? l["ignore-pattern"].some(
        (n) => U(s, n, {
          nocomment: !0
        })
      ) : !1) && a.properties.length > 1) {
        let n = (o) => o.type === "Identifier" && o.name === "styled", p = (o) => o !== void 0 && o.type === "CallExpression" && (o.callee.type === "MemberExpression" && n(o.callee.object) || o.callee.type === "CallExpression" && n(o.callee.callee));
        if (!l["styled-components"] && (p(a.parent) || a.parent.type === "ArrowFunctionExpression" && p(a.parent.parent)))
          return;
        let t = (o) => o.reduce(
          (f, c) => {
            var $;
            if (c.type === "SpreadElement" || c.type === "RestElement")
              return f.push([]), f;
            let d = K(c, e.sourceCode), g = ($ = f.at(-1)) == null ? void 0 : $.at(-1);
            l["partition-by-comment"] && d && Y(
              l["partition-by-comment"],
              d.value
            ) && f.push([]);
            let y, b = "ignore", C = [], { getGroup: h, setCustomGroups: N } = R(l.groups);
            c.key.type === "Identifier" ? { name: y } = c.key : c.key.type === "Literal" ? y = `${c.key.value}` : y = e.sourceCode.text.slice(...c.key.range);
            let x = {
              size: I(c.range),
              node: c,
              name: y
            };
            l["partition-by-new-line"] && g && W(e.sourceCode, g, x) && f.push([]), c.value.type === "AssignmentPattern" && ((V) => {
              V.right.type === "Identifier" && C.push(V.right.name);
              let ce = (D) => {
                let z = [];
                switch (D.type) {
                  case "ArrowFunctionExpression":
                    z.push(D.body);
                    break;
                  case "ConditionalExpression":
                    z.push(D.consequent, D.alternate);
                    break;
                  case "LogicalExpression":
                  case "BinaryExpression":
                    z.push(D.left, D.right);
                    break;
                  case "CallExpression":
                    z.push(...D.arguments);
                    break;
                }
                z.forEach((_) => {
                  _.type === "Identifier" && C.push(_.name), (_.type === "BinaryExpression" || _.type === "ConditionalExpression") && ce(_);
                });
              };
              switch (V.right.type) {
                case "ArrowFunctionExpression":
                case "ConditionalExpression":
                case "LogicalExpression":
                case "BinaryExpression":
                case "CallExpression":
                  ce(V.right);
                  break;
              }
            })(c.value), N(l["custom-groups"], y);
            let S = {
              ...x,
              group: h(),
              dependencies: C,
              position: b
            };
            return f.at(-1).push(S), f;
          },
          [[]]
        );
        for (let o of t(a.properties))
          P(o, (f, c) => {
            let d = E(l.groups, f), g = E(l.groups, c);
            if (d > g || d === g && O(w(f, c, l))) {
              let y = (b) => {
                let C = {};
                for (let N of o) {
                  let x = E(l.groups, N);
                  x in C ? C[x] = v(
                    [...C[x], N],
                    l
                  ) : C[x] = [N];
                }
                let h = [];
                for (let N of Object.keys(C).sort(
                  (x, S) => Number(x) - Number(S)
                ))
                  h.push(...v(C[N], l));
                return M(
                  b,
                  o,
                  h,
                  e.sourceCode,
                  {
                    partitionComment: l["partition-by-comment"]
                  }
                );
              };
              e.report({
                messageId: "unexpectedObjectsOrder",
                data: {
                  left: k(f.name),
                  right: k(c.name)
                },
                node: c.node,
                fix: y
              });
            }
          });
      }
    };
    return {
      ObjectExpression: i,
      ObjectPattern: i
    };
  }
}), pe = "sort-classes", Pe = A({
  name: pe,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted classes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedClassesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    ClassBody: (i) => {
      if (i.body.length > 1) {
        let a = j(e.options.at(0), {
          type: u.alphabetical,
          order: m.asc,
          "ignore-case": !1,
          groups: ["property", "constructor", "method", "unknown"]
        }), l = i.body.map((s) => {
          var f;
          let r, { getGroup: n, defineGroup: p } = R(a.groups);
          s.type === "StaticBlock" ? r = "static" : s.type === "TSIndexSignature" ? r = e.sourceCode.text.slice(
            s.range.at(0),
            ((f = s.typeAnnotation) == null ? void 0 : f.range.at(0)) ?? s.range.at(1)
          ) : s.key.type === "Identifier" ? { name: r } = s.key : r = e.sourceCode.text.slice(...s.key.range);
          let t = r.startsWith("_") || r.startsWith("#"), o = "decorators" in s && s.decorators.length > 0;
          if (s.type === "MethodDefinition") {
            s.kind === "constructor" && p("constructor");
            let c = s.accessibility === "private" || t, d = s.static;
            o && (s.kind === "get" && p("decorated-get-method"), s.kind === "set" && p("decorated-set-method"), p("decorated-method")), c && d && p("static-private-method"), c && p("private-method"), d && p("static-method"), s.kind === "get" && p("get-method"), s.kind === "set" && p("set-method"), p("method");
          } else
            s.type === "TSIndexSignature" ? p("index-signature") : s.type === "AccessorProperty" ? o && ((s.accessibility === "private" || t) && p("private-decorated-accessor-property"), p("decorated-accessor-property")) : s.type === "PropertyDefinition" && (o && ((s.accessibility === "private" || t) && p("private-decorated-property"), p("decorated-property")), (s.accessibility === "private" || t) && p("private-property"), s.static && p("static-property"), p("property"));
          return {
            size: I(s.range),
            group: n(),
            node: s,
            name: r
          };
        });
        P(l, (s, r) => {
          let n = E(a.groups, s), p = E(a.groups, r);
          s.name !== r.name && (n > p || n === p && O(w(s, r, a))) && e.report({
            messageId: "unexpectedClassesOrder",
            data: {
              left: k(s.name),
              right: k(r.name)
            },
            node: r.node,
            fix: (t) => {
              let o = [], f = l.reduce(
                (d, g) => {
                  let y = E(a.groups, g);
                  return y in d ? d[y] = v(
                    [...d[y], g],
                    a
                  ) : d[y] = [g], d;
                },
                {}
              ), c = Object.keys(f).sort((d, g) => Number(d) - Number(g)).reduce(
                (d, g) => [
                  ...d,
                  ...f[g]
                ],
                []
              );
              for (let d = 0, g = c.length; d < g; d++)
                o.push(
                  t.replaceTextRange(
                    L(l.at(d).node, e.sourceCode),
                    e.sourceCode.text.slice(
                      ...L(
                        c.at(d).node,
                        e.sourceCode
                      )
                    )
                  )
                );
              return o;
            }
          });
        });
      }
    }
  })
}), ue = "sort-enums", Te = A({
  name: ue,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted TypeScript enums"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "partition-by-comment": {
            default: !1,
            type: ["boolean", "string", "array"]
          },
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedEnumsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    TSEnumDeclaration: (i) => {
      if (i.members.length > 1 && i.members.every(({ initializer: a }) => a)) {
        let a = j(e.options.at(0), {
          type: u.alphabetical,
          order: m.asc,
          "ignore-case": !1,
          "partition-by-comment": !1
        }), l = a["partition-by-comment"], s = i.members.reduce(
          (r, n) => {
            let p = K(n, e.sourceCode);
            l && p && Y(l, p.value) && r.push([]);
            let o = {
              name: n.id.type === "Literal" ? `${n.id.value}` : `${e.sourceCode.text.slice(...n.id.range)}`,
              node: n,
              size: I(n.range)
            };
            return r.at(-1).push(o), r;
          },
          [[]]
        );
        for (let r of s)
          P(r, (n, p) => {
            O(w(n, p, a)) && e.report({
              messageId: "unexpectedEnumsOrder",
              data: {
                left: k(n.name),
                right: k(p.name)
              },
              node: p.node,
              fix: (t) => M(
                t,
                r,
                v(r, a),
                e.sourceCode,
                { partitionComment: l }
              )
            });
          });
      }
    }
  })
}), de = "sort-maps", Me = A({
  name: de,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Map elements"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              u.alphabetical,
              u.natural,
              u["line-length"]
            ],
            default: u.alphabetical,
            type: "string"
          },
          order: {
            enum: [m.asc, m.desc],
            default: m.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedMapElementsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: u.alphabetical,
      order: m.asc
    }
  ],
  create: (e) => ({
    NewExpression: (i) => {
      if (i.callee.type === "Identifier" && i.callee.name === "Map" && i.arguments.length && i.arguments[0].type === "ArrayExpression") {
        let [{ elements: a }] = i.arguments;
        if (a.length > 1) {
          let l = j(e.options.at(0), {
            type: u.alphabetical,
            "ignore-case": !1,
            order: m.asc
          }), s = a.reduce(
            (r, n) => (n === null || n.type === "SpreadElement" ? r.push([]) : r.at(-1).push(n), r),
            [[]]
          );
          for (let r of s) {
            let n = r.map((p) => {
              let t;
              if (p.type === "ArrayExpression") {
                let [o] = p.elements;
                o ? o.type === "Literal" ? t = o.raw : t = e.sourceCode.text.slice(...o.range) : t = `${o}`;
              } else
                t = e.sourceCode.text.slice(...p.range);
              return {
                size: I(p.range),
                node: p,
                name: t
              };
            });
            P(n, (p, t) => {
              O(w(p, t, l)) && e.report({
                messageId: "unexpectedMapElementsOrder",
                data: {
                  left: k(p.name),
                  right: k(t.name)
                },
                node: t.node,
                fix: (o) => M(
                  o,
                  n,
                  v(n, l),
                  e.sourceCode
                )
              });
            });
          }
        }
      }
    }
  })
}), Le = "eslint-plugin-perfectionist";
let X = (e) => {
  let i = {
    [le]: [
      "error",
      {
        groups: [
          "type",
          ["builtin", "external"],
          "internal-type",
          "internal",
          ["parent-type", "sibling-type", "index-type"],
          ["parent", "sibling", "index"],
          "object",
          "unknown"
        ],
        "custom-groups": {
          value: {},
          type: {}
        },
        "newlines-between": "always",
        "internal-pattern": ["~/**"]
      }
    ],
    [pe]: [
      "error",
      {
        groups: [
          "index-signature",
          "static-property",
          "private-property",
          "property",
          "constructor",
          "static-method",
          "private-method",
          "method",
          ["get-method", "set-method"],
          "unknown"
        ]
      }
    ],
    [ie]: [
      "error",
      {
        "partition-by-comment": !1
      }
    ],
    [Z]: [
      "error",
      {
        "spread-last": !0
      }
    ],
    [H]: ["error"],
    [Q]: ["error"],
    [F]: ["error"],
    [ee]: ["error"],
    [te]: ["error"],
    [re]: ["error"],
    [se]: ["error"],
    [ae]: ["error"],
    [oe]: ["error"],
    [ne]: ["error"],
    [ue]: ["error"],
    [de]: ["error"]
  };
  return {
    rules: Object.fromEntries(
      Object.entries(i).map(([a, [l, s = {}]]) => [
        `perfectionist/${a}`,
        [l, Object.assign(s, e)]
      ])
    ),
    plugins: ["perfectionist"]
  };
};
const _e = {
  rules: {
    [Z]: Ee,
    [Q]: xe,
    [pe]: Pe,
    [ue]: Te,
    [ne]: Ie,
    [le]: Oe,
    [ae]: ke,
    [oe]: Ae,
    [de]: Me,
    [ee]: Ce,
    [te]: ve,
    [re]: Se,
    [ie]: je,
    [H]: be,
    [se]: we,
    [F]: Ne
  },
  configs: {
    "recommended-alphabetical": X({
      type: u.alphabetical,
      order: m.asc,
      "ignore-case": !1
    }),
    "recommended-natural": X({
      type: u.natural,
      order: m.asc,
      "ignore-case": !1
    }),
    "recommended-line-length": X({
      type: u["line-length"],
      order: m.desc
    })
  },
  name: Le
};
export {
  _e as default
};
